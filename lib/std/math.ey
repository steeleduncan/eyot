// 64 bit float arithmetic (cpu only)
export cpu fn sqrt(val f64) f64 {
    return ey_stdlib_sqrtd(val)
}
export cpu fn exp(val f64) f64 {
    return ey_stdlib_expd(val)
}
export cpu fn cos(val f64) f64 {
    return ey_stdlib_cosd(val)
}
export cpu fn sin(val f64) f64 {
    return ey_stdlib_sind(val)
}
export cpu fn tan(val f64) f64 {
    return ey_stdlib_tand(val)
}
export cpu fn log(val f64) f64 {
    return ey_stdlib_logd(val)
}

// 32 bit float square root
export cpu fn sqrtf(val f32) f32 {
    return ey_stdlib_sqrtf(val)
}
export gpu fn sqrtf(val f32) f32 {
    return gpubuiltin::sqrt(val)
}
export cpu fn expf(val f32) f32 {
    return ey_stdlib_expf(val)
}
export gpu fn expf(val f32) f32 {
    return gpubuiltin::exp(val)
}

export cpu fn pi() f64 {
    return 3.14159265359
}

// TODO these should be replaced with native variants
export cpu fn rand() i64 {
    return ey_stdlib_rand()
}

export cpu fn rand_max() i64 {
    return ey_stdlib_rand_max()
}

// box muller transform for a random variable with mean 0, standard deviation 1
export cpu fn rand_normal() f64 {
    const epsilon = 0.00000001
    
    let u1 = 0.0
    let u2 = 0.0

    while true {
        u1 = (rand() as f64) / ((rand_max() as f64) + 1.0);
        if u1 >= epsilon {
            break
        }
    }
    while true {
        u2 = (rand() as f64) / ((rand_max() as f64) + 1.0);
        if u2 >= epsilon {
            break
        }
    }
    const magnitude = sqrt(-2.0 * log(u1));

    return magnitude * cos(2.0 * pi() * u2);

    // NB there is a second useable value: magnitude * sin(2.0 * M_PI * u2);
}
